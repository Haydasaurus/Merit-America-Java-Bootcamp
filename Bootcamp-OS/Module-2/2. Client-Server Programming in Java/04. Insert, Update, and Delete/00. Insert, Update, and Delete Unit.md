# Introduction

You've learned how to retrieve data from a database, but how does that data get there in the first place? Part of the usefulness of databases is storing and retrieving data, but that usefulness diminishes if you can't also change the data. For instance, what if your database stored class rostersâ€”how would you handle adding a new student that signed up late, or removing them if they dropped the course?

Thankfully, there are three SQL statements that can add, change, and remove data from the database.

---

# Inserting new rows

To add a row, use an `INSERT` statement:

```sql
INSERT INTO country (code, name, continent, region)
VALUES ('HND', 'Honduras', 'North America', 'Central America');
```

This creates a new row in your country table and fills in the column of that row with these values:

```sql
SELECT * FROM country WHERE continent = 'North America';
```

Result:

| **code** | **name**       | **continent** | **region**      |
| -------- | -------------- | ------------- | --------------- |
| HND      | Honduras       | North America | Central America |
| CYM      | Cayman Islands | North America | Caribbean       |
| ...      | ...            | ...           | ...             |

This is the syntax for an `INSERT` statement:

```
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```

>**âœ” Tip: The columns are optional, but use them**
>
>Technically, the column list is optional in an `INSERT` statement, and the database assumes that your `VALUES` are in the same order that the columns were defined in when the table was created. How do you know what that order is?
>
>There are ways of looking it up, but it's best to list out the columns. There's a chance that the columns are in a different order on development versus production and it reduces ambiguity. List out the columns in the `INSERT` statement so you don't have to worry about it.
>
>Remember: It pays to be explicit.

## Serial columns on inserts

In the preceding example, the country of `'Honduras'` was added to the `country` table with a primary key value of `'HND'`. Country codes are generated by an international standards body, and as such, are known as **natural** keys. Other well-known natural keys include Social Security Numbers, US State Abbreviations, and Zip Codes.

There aren't many natural keys available in real life, and database tables frequently need to use **surrogate** keys for their primary keys. Surrogate key values are generated by the database system and usually take the form of an auto-incrementing integer, or `serial` column, where each new value adds one to itself. So the generated values are 1, 2, 3, 4, and so on.

For example, assuming a simple `city` table with only four columns, serial `city_id`, `country_code`, `name`, and `population`, adding `'Tegucigalpa'` to `'Honduras'` is accomplished with the following SQL:

```sql
INSERT INTO city (country_code, name, population) VALUES ('HND', 'Tegucigalpa', 1276738);
```

Note that the surrogate primary key, `city_id`, isn't included anywhere in the `INSERT` statement. This is common for surrogate keys. Since their values are generated by the database system, there's no need to include them in the `INSERT` statement.

Then again, not including the surrogate key makes it difficult to get the newly generated value, and there are occasions when it's best to obtain the value. Perhaps the value is needed for a foreign key in another table that's part of a multi-table process.

Fortunately, all that's required to obtain the new value is adding a `RETURNING` clause with the name of the surrogate key column you want returned at the end of the `INSERT` statement. In the case of adding `Tegucigalpa` to `Honduras`, add `RETURNING city_id`:

```sql
INSERT INTO city (country_code, name, population)
VALUES ('HND', 'Tegucigalpa', 1276738) RETURNING city_id;
```

>**âœ” Tip: The advantages of RETURNING**
>
>There are two primary advantages to using the `RETURNING` clause. First, it avoids an extra database query to retrieve the value. You could always retrieve the new `id` for `'Tegucigalpa'` after it was inserted with this:
>
>```sql
>SELECT city_id FROM city WHERE country_code = 'HND' AND name = 'Tegucigalpa';
>```
>
>But `RETURNING city_id` avoids the extra query and gives it back for free.
>
>Second, it may be difficult to reliably retrieve the new value. Imagine you've added "Susan Smith" to a `customer` table with over 5,000,000 rows. How confident are you that a subsequent query for "Susan Smith" will return the row of the "Susan Smith?" `RETURNING` the surrogate key column resolves the ambiguity.

## Subquery primary key

Continuing with the `Tegucigalpa` example, there's another technique that's commonly used when inserting rows into a table with one or more foreign keys such as `country_code` in the `city` table. Rather than hardcoding the primary key, `HND` for `Honduras`, you can use a subquery to retrieve the primary key for `Honduras` from the `country` table:

```sql
INSERT INTO city (country_code, name, population)
VALUES ((SELECT code FROM country WHERE name = 'Honduras'), 'Tegucigalpa', 1276738);
```

The subquery `(SELECT code FROM country WHERE name = 'Honduras')` replaces the hardcoded `'HND'`. Like all subqueries, it's wrapped in `()`, and in this case, contains a single column in the `SELECT` clause, the primary key value for `'Honduras'`.

Since country names are unique within the `country` table, the subquery's `WHERE name = 'Honduras'` returns a single row. Because the `SELECT` statement only includes one column, `code`, the entire subquery results in a single value, the primary key for `Honduras`. The primary key is used for the `country_code` column of the `INSERT` statement.

You may use similar subqueries anytime you need to retrieve the primary key from another table for use with a foreign key when inserting into a table with one or more foreign keys. In other words, you may write as many subqueries as there are foreign keys in the `INSERT INTO` table if you want. The only requirement is that each subquery results in a single value. The `WHERE` clause of the subquery must return a single row, and the `SELECT` may contain only one column.

>**ðŸ›ˆ Note: Subquerying the primary key elsewhere**
>
>You may find subquerying the primary key useful elsewhere in SQL, including `UPDATE` and `DELETE` statements, which are covered in the next lessons.

---

# Updating existing rows

Data is often changed in a systemâ€”for example, changing your user profile or updating a blog postâ€”so having a way to update data is important. For instance, you can use an `UPDATE` statement to change the name of Honduras to its full, official name:

```sql
UPDATE country SET name = 'The Republic of Honduras'
WHERE code = 'HND';
```

You'll see the familiar `WHERE` clause here, which now selects which rows you want to update.

>**âš  Warning: Use your WHERE clause on every UPDATE**
>
>If you forget the `WHERE` clause, the update happens on every row in the table, changing all of your data. To make sure that you update the correct rows, write a `SELECT` statement first:
>
>```sql
>SELECT * FROM country
>WHERE code = 'HND';
>```
>
>Once you've verified that it brings back the rows you want, change it to an `UPDATE` statement.

Here's the structure of an `UPDATE` statement:

```sql
UPDATE table_name SET column1 = value1, column2 = value2, ...
WHERE condition;
```

---

# Deleting rows

Sometimes you want to delete data from the database and remove it completely. You can do this with a `DELETE` statement:

```
DELETE FROM country
WHERE code = 'HND';
```

This deletes any row from the database that matches the `WHERE` clause.

>**âš  Danger: Be sure of what you're deleting**
>
>As stated with `UPDATE` statements, if you leave off the `WHERE` clause on a `DELETE` statement, all the rows in the table get deleted. There is no undo in SQL, at least not yet, _so once they're gone, they're gone._
>
>It's better to write a `SELECT` statement first, make sure those are the rows you want to delete, and then change it to a `DELETE` statement afterwards.

This is the standard format of a `DELETE` statement:

```
DELETE FROM table_name
WHERE condition;
```

>**ðŸ›ˆ Note: In most real world applications, you don't delete often**
>
>In most real applications, you don't delete a lot of data. Data is valuable and keeping data that you don't need anymore can have its advantages. If a customer calls and says that they accidentally deleted something they didn't mean to, you'll be glad you kept it in the database.
>
>So how are deletes handled then? Usually, you have a boolean column like `enabled` or `deleted`, or a date column like `deleted_date`, and set that when you want something "deleted." Then all of your `SELECT` statements can look for that when pulling data from the database.
>
>You can retrieve all users accounts from a database that haven't been deleted like this:
>
>```sql
>SELECT * FROM user_account
>WHERE deleted_date IS NULL;
>```

---

# Table constraints

You've learned about keys and how those keys can create links between the rows in your tables. You can then join your tables together with those links and create relations between the tables.

But those links also perform another function. They act as a **constraint** on your data and how you're allowed to interact with it.

Constraints control what you're allowed to do with the data in the database. They protect the integrity and validity of the database. Whenever you update, insert, or delete rows in the database, the DBMS checks that data against constraints defined in the tables and rejects any changes that conflict with those constraints.

Think back to the example from the lesson about primary and foreign keys:

**country**

| **country_id** | **name** |
| -------------- | -------- |
| 1              | Canada   |
| 2              | Mexico   |
| 3              | Cuba     |
| 4              | France   |
| 5              | Spain    |
| 6              | Italy    |
| 7              | China    |

**city**

| **city_id** | **country_id** | **name** |
| ----------- | -------------- | -------- |
| 1           | 6              | Milan    |
| 2           | 6              | Rome     |
| 3           | 7              | Beijing  |
| 4           | 4              | Nice     |
| 5           | 4              | Paris    |
| 6           | 1              | Toronto  |
| 7           | 5              | Seville  |

These two tables both have primary keys, but the city table also has a foreign key called `country_id` that links to the country table. In SQL, that looks something like this:

```sql
ALTER TABLE city ADD FOREIGN KEY (country_id) REFERENCES country(country_id);
```

If you had this data in the database and you wanted to delete Mexico, that would be fine:

```sql
DELETE FROM country WHERE country_id = 2;
```

You can delete that country because nothing else relies on it. There are no cities for Mexico in the database and nothing prevents Mexico from being deleted.

However, if you tried to delete Canada with the following statement, you'd get an error:

```sql
DELETE FROM country WHERE country_id = 1;
```

```sql
ERROR: update or delete on table "country" violates foreign key constraint "fk_country_id" on table "city"
  Detail: Key (country_id)=(1) is still referenced from table "city".
```

That didn't work because you have a constraint on the city table called a **Foreign Key Constraint**. If any row in the city table references the row in the country table you want to delete, then that country row canâ€™t be deleted.

These constraints help you keep your data consistent and prevent you from having data that points to something that doesn't exist.

## Other types of constraints

There are other types of constraints that you can put on columns in your database as well. One example is the data type that's defined on a column. But there are a few more that can help you design your database tables to make sure they never contain data that you don't want them to contain:

| **Constraint Type** | **Description**                                                                                                             |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `UNIQUE`            | Verifies the value in this column is unique among all the rows in this table. Good for usernames and email address columns. |
| `NOT NULL`          | Verifies that all rows in this table have a value for this column and the column is never set to NULL.                      |
| `DEFAULT value`     | If a row is entered and this column isn't given a value, it gets the set default value. For example, DEFAULT 0.             |
| `CHECK`             | Verifies that the value in this column meets a programmer-defined condition, like AGE >= 18.                                |

---

# Transactions

One issue with SQL is that you can only run one statement at a time and that the statements are separated from each other. If one of the statements fails, it can be difficult or impossible to reverse anything that came before. For example, imagine that you want to transfer money from one bank account to another, and you have this table:

**account**

| **account_number** | **name** | **balance** |
| ------------------ | -------- | ----------- |
| 383953             | Bob      | 100.00      |
| 485920             | Jane     | 403.00      |

If you want to transfer $25.00 from Bob to Jane, you'd need two statements to do that:

```sql
UPDATE account SET balance = balance - 25 WHERE account_number = 383953;
UPDATE account SET balance = balance + 25 WHERE account_number = 485920;
```

Most of the time this works, but what if something goes wrong? What if the database crashes right after you take $25 from Bob and the second statement throws an error? You'd be in an inconsistent state.

You want the transfer to be considered as a single action. The money is either transferred or it's not. It must never be in an in-between state. What you want is for this action to be ACID compliant. **ACID** is an acronym for Atomicity, Consistency, Isolation, and Durability.

The following table explains what each property means:

|             |                                                                                                                                                                                          |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Atomicity   | This means that the statements in your transaction either all happen or none of them happen.                                                                                             |
| Consistency | This means that your database must never be in a state where one statement has run, and the other hasn't yet. In other words, all statements in the transaction happen at the same time. |
| Isolation   | This means that no one else on the database sees the results of the statements until they're all completed.                                                                              |
| Durable     | This means that once the statements run, they're permanent and saved in the database.                                                                                                    |

Most SQL databases use transactions to achieve ACID compliance.

### Running statements in a transaction

You can group SQL statements together into a **transaction**. Instead of calling the two statements separately, like you did earlier, you can instead group them together in an ACID-compliant transaction:

```sql
BEGIN TRANSACTION;
UPDATE account SET balance = balance - 25 WHERE account_number = 383953;
UPDATE account SET balance = balance + 25 WHERE account_number = 485920;
COMMIT;
```

Now, the first line in your SQL call starts a new transaction. A transaction is like a temporary sandbox that you can use to manipulate the data without affecting the data for others. You're in your own world now and can change and update all you want.

If either of these statements fail, nothing from that transaction gets saved to the database, keeping the transaction atomic and consistent. Since you're in your own world, the statements are also fully isolated from anyone else on the system.

After running statements in a transaction, you then have two options. Like in the example, you can `COMMIT` the transaction, which applies the changes to the database all at once, or you can `ROLLBACK`, which discards all the changes and keeps the database as if nothing had changed.

Transactions aren't used all the time and aren't necessary for `SELECT` statements since nothing changes. But they're useful if you have multiple statements that must happen as one single change.

---

# Unit summary

In this unit, you learned:

-   How to add new rows to a database table.
-   How to update existing rows in a database table.
-   How to delete rows from a database table.
-   How to add constraints.
-   How database transactions help ensure Atomicity, Consistency, Isolation, and Durability (ACID).

---

# Quiz

## **Insert, Update, and Delete 1**

**What type of constraint ensures values in a column must reference an existing record in another table?**

â—‹ Primary key

â—‰ Foreign key

â—‹ Check constraint

â—‹ Not null constraint

â—‹ Unique constraint

**Explanation:** Foreign keys relate to data in other tables, and foreign key constraints enforce that the data must exist.


## **Insert, Update, and Delete 2**

**`INSERT` statements require the column names of the table.**

â—‹ True

â—‰ False

**Explanation:** It's not required, but considered a good practice, to explicitly list the column names to make sure your values align with the correct columns.


## **Insert, Update, and Delete 3**

**What clause can you add to an `INSERT` statement to get the id for a newly inserted row?**

â—‹ `SERIAL`

â—‰ `RETURNING`

â—‹ `OUTPUT`

â—‹ `WITH ID`

**Explanation:** A `RETURNING` clause added to the end of an `INSERT` statement returns the value specified in the clause.


## **Insert, Update, and Delete 4**

```sql
INSERT INTO person (person_id, last_name, middle_name, first_name)
VALUES (100, 'Howard', 'Lee', 'Scott');

SELECT first_name
FROM person
WHERE person_id = 100;
```

**What value would get returned from the `SELECT` statement?**

â—‹ Howard

â—‹ Lee

â—‰ Scott

**Explanation:** The column list in the `INSERT` statement has `first_name` as the last column, which the value `'Scott'` maps to.


## **Insert, Update, and Delete 5**

**Assume this data is in a table named `president`:**

| **first_name** | **last_name** | **number** | **term_begin**        | **term_end** |
| -------------- | ------------- | ---------- | --------------------- | ------------ |
| George         | Washington    | 1          | 1789-04-30            | 1797-03-04   |
| John           | Adams         | 2          | 1797-03-04            | 1801-03-04   |
| Thomas         | Jefferson     | 3          | 1801-03-04            | 1809-03-04   |
| James          | Madison       | 4          | 1809-03-04            | 1817-03-04   |
| James          | Monroe        | 5          | 1817-03-04\1825-03-04 |              |

**How many rows would remain in the table after the following statement runs?**

```sql
DELETE FROM president;
```

**Answer:** 0

**Explanation:** The statement has no `WHERE` clause so the statement deletes all rows in the table.


## **Insert, Update, and Delete 6**

**Assume this data is in a table named `president`:**

| **first_name** | **last_name** | **number** | **term_begin**        | **term_end** |
| -------------- | ------------- | ---------- | --------------------- | ------------ |
| George         | Washington    | 1          | 1789-04-30            | 1797-03-04   |
| John           | Adams         | 2          | 1797-03-04            | 1801-03-04   |
| Thomas         | Jefferson     | 3          | 1801-03-04            | 1809-03-04   |
| James          | Madison       | 4          | 1809-03-04            | 1817-03-04   |
| James          | Monroe        | 5          | 1817-03-04\1825-03-04 |              |

**How many rows would remain in the table after the following statement runs?**

```sql
DELETE FROM president
WHERE first_name LIKE 'J%';
```

**Answer:** 2

**Explanation:** The statement deletes all rows where `first_name` starts with the letter Jâ€”that's John Adams, James Madison, and James Monroe.


## **Insert, Update, and Delete 7**

**Assume this data is in a table named `president`:**

| **first_name** | **last_name** | **number** | **term_begin**        | **term_end** |
| -------------- | ------------- | ---------- | --------------------- | ------------ |
| George         | Washington    | 1          | 1789-04-30            | 1797-03-04   |
| John           | Adams         | 2          | 1797-03-04            | 1801-03-04   |
| Thomas         | Jefferson     | 3          | 1801-03-04            | 1809-03-04   |
| James          | Madison       | 4          | 1809-03-04            | 1817-03-04   |
| James          | Monroe        | 5          | 1817-03-04\1825-03-04 |              |

**If you run the following `UPDATE` statement:**

```sql
UPDATE president
SET first_name = 'Jim'
WHERE first_name = 'James'
AND number < 5;
```

**What value would get returned by the following `SELECT` statement?**

```sql
SELECT first_name
FROM president
WHERE last_name = 'Monroe';
```

**Answer:** James

**Explanation:** The `UPDATE` statement affects only James Madison, because the `WHERE` condition is `number < 5`.


## **Insert, Update, and Delete 8**

**Assume this data is in a table named `president`:**

| **first_name** | **last_name** | **number** | **term_begin**        | **term_end** |
| -------------- | ------------- | ---------- | --------------------- | ------------ |
| George         | Washington    | 1          | 1789-04-30            | 1797-03-04   |
| John           | Adams         | 2          | 1797-03-04            | 1801-03-04   |
| Thomas         | Jefferson     | 3          | 1801-03-04            | 1809-03-04   |
| James          | Madison       | 4          | 1809-03-04            | 1817-03-04   |
| James          | Monroe        | 5          | 1817-03-04\1825-03-04 |              |

**If you run the following series of statements:**

```sql
BEGIN TRANSACTION;

UPDATE president
SET number = number * 2;

ROLLBACK;
```

**What value would get returned by the following `SELECT` statement?**

```sql
SELECT last_name
FROM president
WHERE number = 4;
```

**Answer:** Madison

**Explanation:** The `ROLLBACK` statement discards all data changes that occurred since the `BEGIN TRANSACTION` statement, so the `number` for James Madison is still 4.