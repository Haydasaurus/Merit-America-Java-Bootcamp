# Inserting new rows

To add a row, use an `INSERT` statement:

```sql
INSERT INTO country (code, name, continent, region)
VALUES ('HND', 'Honduras', 'North America', 'Central America');
```

This creates a new row in your country table and fills in the column of that row with these values:

```sql
SELECT * FROM country WHERE continent = 'North America';
```

Result:

| **code** | **name**       | **continent** | **region**      |
| -------- | -------------- | ------------- | --------------- |
| HND      | Honduras       | North America | Central America |
| CYM      | Cayman Islands | North America | Caribbean       |
| ...      | ...            | ...           | ...             |

This is the syntax for an `INSERT` statement:

```
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
```

>**âœ” Tip: The columns are optional, but use them**
>
>Technically, the column list is optional in an `INSERT` statement, and the database assumes that your `VALUES` are in the same order that the columns were defined in when the table was created. How do you know what that order is?
>
>There are ways of looking it up, but it's best to list out the columns. There's a chance that the columns are in a different order on development versus production and it reduces ambiguity. List out the columns in the `INSERT` statement so you don't have to worry about it.
>
>Remember: It pays to be explicit.

## Serial columns on inserts

In the preceding example, the country of `'Honduras'` was added to the `country` table with a primary key value of `'HND'`. Country codes are generated by an international standards body, and as such, are known as **natural** keys. Other well-known natural keys include Social Security Numbers, US State Abbreviations, and Zip Codes.

There aren't many natural keys available in real life, and database tables frequently need to use **surrogate** keys for their primary keys. Surrogate key values are generated by the database system and usually take the form of an auto-incrementing integer, or `serial` column, where each new value adds one to itself. So the generated values are 1, 2, 3, 4, and so on.

For example, assuming a simple `city` table with only four columns, serial `city_id`, `country_code`, `name`, and `population`, adding `'Tegucigalpa'` to `'Honduras'` is accomplished with the following SQL:

```sql
INSERT INTO city (country_code, name, population) VALUES ('HND', 'Tegucigalpa', 1276738);
```

Note that the surrogate primary key, `city_id`, isn't included anywhere in the `INSERT` statement. This is common for surrogate keys. Since their values are generated by the database system, there's no need to include them in the `INSERT` statement.

Then again, not including the surrogate key makes it difficult to get the newly generated value, and there are occasions when it's best to obtain the value. Perhaps the value is needed for a foreign key in another table that's part of a multi-table process.

Fortunately, all that's required to obtain the new value is adding a `RETURNING` clause with the name of the surrogate key column you want returned at the end of the `INSERT` statement. In the case of adding `Tegucigalpa` to `Honduras`, add `RETURNING city_id`:

```sql
INSERT INTO city (country_code, name, population)
VALUES ('HND', 'Tegucigalpa', 1276738) RETURNING city_id;
```

>**âœ” Tip: The advantages of RETURNING**
>
>There are two primary advantages to using the `RETURNING` clause. First, it avoids an extra database query to retrieve the value. You could always retrieve the new `id` for `'Tegucigalpa'` after it was inserted with this:
>
>```sql
>SELECT city_id FROM city WHERE country_code = 'HND' AND name = 'Tegucigalpa';
>```
>
>But `RETURNING city_id` avoids the extra query and gives it back for free.
>
>Second, it may be difficult to reliably retrieve the new value. Imagine you've added "Susan Smith" to a `customer` table with over 5,000,000 rows. How confident are you that a subsequent query for "Susan Smith" will return the row of the "Susan Smith?" `RETURNING` the surrogate key column resolves the ambiguity.

## Subquery primary key

Continuing with the `Tegucigalpa` example, there's another technique that's commonly used when inserting rows into a table with one or more foreign keys such as `country_code` in the `city` table. Rather than hardcoding the primary key, `HND` for `Honduras`, you can use a subquery to retrieve the primary key for `Honduras` from the `country` table:

```sql
INSERT INTO city (country_code, name, population)
VALUES ((SELECT code FROM country WHERE name = 'Honduras'), 'Tegucigalpa', 1276738);
```

The subquery `(SELECT code FROM country WHERE name = 'Honduras')` replaces the hardcoded `'HND'`. Like all subqueries, it's wrapped in `()`, and in this case, contains a single column in the `SELECT` clause, the primary key value for `'Honduras'`.

Since country names are unique within the `country` table, the subquery's `WHERE name = 'Honduras'` returns a single row. Because the `SELECT` statement only includes one column, `code`, the entire subquery results in a single value, the primary key for `Honduras`. The primary key is used for the `country_code` column of the `INSERT` statement.

You may use similar subqueries anytime you need to retrieve the primary key from another table for use with a foreign key when inserting into a table with one or more foreign keys. In other words, you may write as many subqueries as there are foreign keys in the `INSERT INTO` table if you want. The only requirement is that each subquery results in a single value. The `WHERE` clause of the subquery must return a single row, and the `SELECT` may contain only one column.

>**ðŸ›ˆ Note: Subquerying the primary key elsewhere**
>
>You may find subquerying the primary key useful elsewhere in SQL, including `UPDATE` and `DELETE` statements, which are covered in the next lessons.