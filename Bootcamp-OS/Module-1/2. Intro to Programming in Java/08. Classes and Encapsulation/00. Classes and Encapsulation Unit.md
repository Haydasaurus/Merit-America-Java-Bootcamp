# Classes and encapsulation

You started working with primitive data types, and they can be disappointingly simplistic. Arrays add some new capability, but they're fixed in size. Fortunately, the collections framework offers the opportunity to work with more complex objects created from class definitions.

Still, what if you want to create your own data type, like the time on a clock?

```java
int hour = 11;
int minute = 23;
int second = 42;
```

This works, but if you want your program to store multiple clocks, you may run into trouble:

```java
int[] hours = new int[] { 11, 8 };
int[] minutes = new int[] { 23, 17 };
int[] seconds = new int[] { 42, 58 };
```

This is a problem, as you need to ensure that all of the values remain in sync, and that you don't inadvertently update `hours[0]` and `minutes[1]`.

Now, you'll learn how to create your own data type that has properties, such as hour and minute. Like a real clock, your data type also ticks, counting second by second.

To do this, you'll create something called a class.

---

# Classes

Programmers often need to solve problems that the Java language doesn't have an out-of-the-box solution for. For example, e-commerce sites require "shopping carts." Social media sites need "user profiles."

To create these sorts of applications, programmers need to represent things like shopping carts and user profiles as custom data types. Using classes, they can define what characteristics and behaviors a data type has.

Here are some of the characteristics and behaviors of a clock:

-   A clock has a current time, based on an hour, minute, and second.
-   A clock can be set to a specific time.
-   A clock tracks time by ticking one second at a time.

Defining characteristics and behaviors within a class helps programmers write clean code. Code remains in its place and can be reused at any time. Programmers can create as many **_instances of objects_** from the class **_blueprint_** as needed. Each instance of the object exhibits the same characteristics and behaviors as defined in the class.

Now, you'll build your own application from an object-based design perspective. First, you'll create **classes**, which serve as blueprints that indicate what variables and methods an object has. Variables and properties represent an object's characteristics, or **state**, and methods define an object's **behaviors**.

>**ðŸ›ˆ Note: Encapsulation**
>
>The bundling of an object's state and behaviors together is part of the definition of **encapsulation**, the first pillar of object-oriented programming. You'll see this term come up again later in this unit as you learn more about classes.

It takes time to become proficient in object modeling. This unit covers the basics.

## Creating classes
The following example shows how to create a class:

```java
// Clock.java
public class Clock {

}
```

The keyword `class` allows you to create your own data type.

## Creating an instance of a class
To declare variables, you might type the following:

```java
int count = 18;
String name = "Bill";
```

To declare a new instance of your class, you type something similar:

```java
Clock clock = new Clock();
```

This code declares a variable of type `Clock`, named `clock`. The next part of the expressionâ€”`new Clock()`â€”allocates memory to hold a newly **_constructed_** instance of the `Clock` class. The `clock` variable stores a reference to that memory location.

>**âœ” Tip: Don't forget `new`**
>
>Remember to use the `new` keyword when working with reference types. Each variable references a different memory location on the heap where the object resides.

---

# Properties

Each class has unique characteristics. Continuing with the clock example, the `Clock` class represents the current hour, minute, and second. Properties add **_state_** to the class. Each individual instance keeps track of its own separate state.

In Java, properties are also commonly called **instance variables**, or sometimes, **attributes**. This unit frequently uses **_instance variable_** interchangeably with **_property_** when discussing Java.

The following syntax adds properties to a class:

```java
// Clock.java
public class Clock {
    // Instance variables
    private int hour;
    private int minute;
    private int second;

    //setters
    public void setHour(int hour) {
        this.hour = hour;
    }

    public void setMinute(int minute) {
        this.minute = minute;
    }

    public void setSecond(int second) {
        this.second = second;
    }

    //getters
    public int getHour() {
        return this.hour;
    }

    public int getMinute() {
        return this.minute;
    }

    public int getSecond() {
        return this.second;
    }
}
```

```java
// Program.java
public static void main(String[] args)
{
    // Instantiate a new instance of a clock
    Clock grandfather = new Clock();

    // Set the time to 12:22:32
    grandfather.setHour(12);
    grandfather.setMinute(22);
    grandfather.setSecond(32);
}
```

>**âœ” Tip: Follow Java coding conventions**
>
>In Java, all instance variables are accessed through methods called **Getters** and **Setters**. These are named based on the instance variable they're for with either the word `get` or `set` before them.
>
>If the instance variable type is `boolean`, you use `is` instead of `get`, for example, `bool isDoorClosed()`.
>
>When using Getters and Setters, keep the following in mind:
>
>-   Getters and Setters follow the standard Java camel case naming convention.
>-   Getters never have a parameter and always return the same data type as the instance variable that it's getting.
>-   Setters always have a single parameter of the same data type as the instance variable being set and return `void`.
>
>Methods, return data types, and parameters are explained later in the unit.

You defined three instance variables of type `int` named `hour`, `minute`, and `second`. This allows you to set them in your class, and they're saved throughout the lifetime of each instance.

The code sample also uses **public** and **private**. These are **access modifiers**. You'll learn more about them later.

>**ðŸ›ˆ Note: About "this"**
>
>The `this` keyword is a special variable that refers to the current instance of an object.
>
>Using this with a variable, such as `this.hour`, is a way to reference the hour property of this specific instance.
>
>In the `setHour()` method, if you wrote `hour = hour`, it would be ambiguous which hour you were referring to. `this` differentiates the two.

## Derived properties
Sometimes, you want properties to represent an object's state, but its value is dependent on other properties. For example, you derive the full name of a person using a combination of first name and last name.

You can add a property that lets your clock return the current time, like "10:34:42." You don't need a fourth property with its own setter. Creating one might mean that the value it returns contradicts the value stored in the hour, minute, and second properties.

A derived property lets you generate the value by relying on the other properties within the class:

```java
// Clock.java
public class Clock {
    // Instance variables
    private int hour;
    private int minute;
    private int second;

    // Derived Property, getter with no setter
    public String getCurrentTime() {
        return this.hour + ":" + this.minute + ":" + this.second;
    }

    public void setHour(int hour) {
        this.hour = hour;
    }

    public void setMinute(int minute) {
        this.minute = minute;
    }

    public void setSecond(int second) {
        this.second = second;
    }

    public int getHour() {
        return this.hour;
    }

    public int getMinute() {
        return this.minute;
    }

    public int getSecond() {
        return this.second;
    }
}
```

```java
// Program.java
public static void main(String[] args) {

    Clock grandfather = new Clock();

    // Set the time to 17:22:32
    grandfather.setHour(17);
    grandfather.setMinute(22);
    grandfather.setSecond(32);

    // Prints "Current time is 17:22:32
    System.out.println("Current time is " + grandfather.getCurrentTime());
}
```

> Note: You can have many derived properties as you want. The single derived property in the example code doesn't mean that classes are limited to a single derived property.

## Property defaults
Like variables, properties are automatically assigned default values depending upon their data type:

-   `0` or `0.0` for numeric types like `int` and `double`, respectively
-   `false` for `boolean`
-   `null` for `String` and other reference types

In most cases the default values are fine, however, there are times when you need to assign something other than the default.

For instance, the code in the previous section uses the derived property `getCurrentTime()`. It returns a string in **_military_** time, `17:22:32`, instead of the **_12-hour_** format most people expect, `5:22:32 PM`.

One way to fix the problem, while still allowing military time as an option, is to add a new `boolean twelveHourFormat` property. You can use it in `getCurrentTime()` to determine which format to return.

If `twelveHourFormat` is `false`, then `getCurrentTime()` returns military time. If `twelveHourFormat` is `true`, `getCurrentTime()` returns a 12-hour formatted string.

Since the default value of a `boolean` is `false`, `getCurrentTime()` always returns military time unless `twelveHourFormat` is set to `true`. The setter `setTwelveHourFormat(true)` can be called before getting the current time string to return a 12-hour formatted string.

But if the 12-hour format is usually preferred, it makes more sense to adjust the "default" value of `twelveHourFormat`. This way, you don't have to remember to call `setTwelveHourFormat(true)`.

To set a default value for a property, you need to assign the desired value in the declaration of the instance variable. In this case, you'd assign `true` to `twelveHourFormat`:

```java
private boolean twelveHourFormat = true;
```

```java
// Clock.java
public class Clock {
    // Instance variables
    private int hour;
    private int minute;
    private int second;

    // Set default value to true for twelveHourFormat
    private boolean twelveHourFormat = true;

    // Derived Property, getter with no setter
    public String getCurrentTime() {
        // Makes use of the twelveHourFormat property
        String currentTime = ":" + this.minute + ":" + this.second;
        if (this.twelveHourFormat) {
            if (this.hour > 12) {
                currentTime = (this.hour - 12) + currentTime + " pm";
            }
            else if (this.hour == 0) {
                currentTime = "12" + currentTime + " am";
            }
            else {
                currentTime = this.hour + currentTime + " am";
            }
        }
        else {
            currentTime = this.hour + currentTime;
        }
        return currentTime;
    }

    public void setHour(int hour) {
        this.hour = hour;
    }

    public void setMinute(int minute) {
        this.minute = minute;
    }

    public void setSecond(int second) {
        this.second = second;
    }

    public void setTwelveHourFormat(boolean twelveHourFormat) {
        this.twelveHourFormat = twelveHourFormat;
    }

    public int getHour() {
        return this.hour;
    }

    public int getMinute() {
        return this.minute;
    }

    public int getSecond() {
        return this.second;
    }

    public boolean isTwelveHourFormat() {
        return this.twelveHourFormat;
    }
}
```

```java
// Program.java
public static void main(String[] args) {

    Clock grandfather = new Clock();

    // Set the time to 17:22:32
    grandfather.setHour(17);
    grandfather.setMinute(22);
    grandfather.setSecond(32);
    // twelveHourFormat defaults to true

    // Prints "Current time is 5:22:32 pm
    System.out.println("Current time is " + grandfather.getCurrentTime());

    // Set the time to 20:36:15
    Clock humveeDashboard = new Clock();
    humveeDashboard.setHour(20);
    humveeDashboard.setMinute(36);
    humveeDashboard.setSecond(15);
    // Override twelveHourFormat default, and set to false
    humveeDashboard.setTwelveHourFormat(false);

    // Prints "Current time is 20:36:15
    System.out.println("Current time is " + humveeDashboard.getCurrentTime());
}
```

---

# Methods

When you need an object to "do something" or perform a behavior, you can use methods.

In the case of the clock, it can **_tick_**. When you invoke the tick method, it changes the state of the class by ticking forward one second at a time.

The following code sample shows how to add a `tick()` method that changes the state of the object:

```java
// Clock.java
public class Clock {
    private int hour;
    private int minute;
    private int second;

    // tick() method changes the value of hour, minute, and second
    // void means nothing is returned
    public void tick() {
        this.second += 1;

        if (this.second >= 60) {
            this.minute += 1;
            this.second = 0;
        }

        if (this.minute >= 60) {
            this.hour += 1;
            this.minute = 0;
        }

        if (this.hour >= 24) {
            this.hour = 0;
        }
    }

    public String getCurrentTime() {
        return String.format("%02d:%02d:%02d", this.hour, this.minute, this.second);
    }

    public void setHour(int hour) {
        this.hour = hour;
    }

    public void setMinute(int minute) {
        this.minute = minute;
    }

    public void setSecond(int second) {
        this.second = second;
    }

    public int getHour() {
        return this.hour;
    }

    public int getMinute() {
        return this.minute;
    }

    public int getSecond() {
        return this.second;
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    Clock grandfather = new Clock();

    // Set the time to 12:22:32
    grandfather.setHour(12);
    grandfather.setMinute(22);
    grandfather.setSecond(32);

    grandfather.tick(); // time will be 12:22:33
    grandfather.tick(); // time will be 12:22:34

    // Prints "Current time is 12:22:34
    System.out.println("Current time is " + grandfather.getCurrentTime());
}
```

>**âœ” Tip: Encapsulate logic with methods**
>
>Using methods allows you to **encapsulate** the logic needed to make your clock function. By encapsulating the internal mechanisms of the class, the user of your class has to interact with it in a predictable way.
>
>Rather than having the user of the clock change the second, minute, and hour manually, the clock ticks and internally manages the values, incrementing by one or rolling over to zero. Ideally, this limits the risk of bugs that appear in your code.

## Parts of a method
A method consists of several parts:

-   An access modifier
-   A return type
-   A method name
-   A parameter list
-   An exception list
-   A method body

The return type and method name are the only two required. The rest are optional.

Besides an exception list, all parts of a method are explained further in this unit. Exceptions are covered in a later unit.

## Method name
Every method has a name, followed by `()`.

By convention, method names are camel case. Here are some examples:

```
tick()
compareTo()
isSleeping()
calculateGrandTotal()
```

There are some rules for method names in Java:

-   Method names are restricted to characters `[A-Z]`, `[a-z]`, `[0-9]`, `$`, and `_`.
-   Method names can't start with a number.
-   Method names must not be a Java keyword.

## Method body
The method body is the code enclosed within the `{}` which follows the `()` of the method name:

```java
public void sayHello() {
    // Method body begins --
    System.out.println("Hello");
    // -- and ends
}
```

## Method return types
In the code example, the method declaration is `public void tick()`. The `void` part of that means the method doesn't return anything.

If you want your method to return something, you can specify the data type of what you want returned from a method. For example, if you want to return an `int` from a method, you'd write it like this:

```java
public int thisMethodReturnsInt() {

}
```

If you want it to return return a `String`, you'd write it this way:

```java
public String thisMethodReturnsString() {

}
```

Nearly any data type that you can use for a variable can be used as a method return type. You'll see more examples in this unit.

## Parameter list
Methods commonly accept values, or **arguments** passed into them through **parameters**.

You can think of a parameter list as a comma-delimited list of variables between the `()` following the method name. Remember all variables have a data type and a name, and the same is true of parameters.

Here are some examples of parameter lists:

```java
(String city)
(String name, int age)
(double cost, Integer quantity)
(Boolean isOnVacation, String location)
```

Parameters are optional, so a method may have **_zero-to-many_** of them, and each may be of any data type.

To carry the parameters as variables analogy a bit further, think of parameters as **method-scoped** variables. They only exist within the body of the method and can only be referenced by code between the `{}` that define the method body.

In other words, parameters are windows into which values, or arguments, and passed into a method.

For example, you may want the clock to sound various alarm messages:

```java
// Clock.java
public String soundAlarm(String message) {
    return (this.getCurrentTime() + " - " + message);
}
```

```java
// Program.java
public static void main(String[] args) {
    Clock alarmClock = new Clock();

    // Call the soundAlarm() method
    System.out.println(alarmClock.soundAlarm("Wake up sleepyhead"));
}
```

> Note: The argument, `"Wake up sleepyhead"`, is _passed-in_ through the `message` parameter.

The current time followed by a hyphen plus the message is displayed in the console:

```
8:52:17 - Wake up sleepyhead
```

---

# Constructors

When you define a class, you want to make sure it'll be instantiated into a usable, known state. That is, when the `new` statement creates a new object, you can assign any values the class needs so the object is ready for use. To do this, you use a constructor.

A **constructor** is a special method of a class that initializes an object of that class. Constructors have the same name as the class they're in, and because they always return an instance of that class, a return type isn't needed.

Below, the `Clock` class has a constructorâ€”`Clock()`. The constructor provides users the ability to set the clock to a specific time through the `hour`, `minute`, and `second` parameters when instantiated:

```java
// Clock.java
public class Clock {
    private int hour;
    private int minute;
    private int second;

    // Constructor has same name and spelling of class.
    // Notice there isn't a return type with constructors.
    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    // Creates a new clock initialized at 11:17:42
    Clock grandfather = new Clock(11, 17, 42);

    // Creates a new clock initialized at 16:11:01
    Clock watch = new Clock(16, 11, 1);
}
```

---

# The static modifier

In Java, the `static` keyword declares that a property or method belongs to the **_class_** itselfâ€”such as the `Clock` classâ€”and not an **_instance_** of itâ€”like `grandfather` and `watch`.

Static properties and methods are useful when there's data or behaviors that shouldn't belong to any instances but are still accessible from all of them. Regardless of which instance accesses or changes the data, it'll be the same for all.

One way to think of `static` properties and methods is that there's only one version of it, regardless of how many instances there are.

## Static properties
Say you wanted to track how many instances of the `Clock` class you have. You could set up a variable and remember to increment that every time you create a new `Clock`, but that would be tedious and error-prone. That variable might not be accessible everywhere that you instantiate a new `Clock`.

Since the number of `Clock` objects is data related to clocks, it belongs in the `Clock` class, and you can increment it every time the constructor is called.

In the following example, there's a new property called `numberOfClocks` that has the `static` modifier, and the property is incremented in the constructor method. Every time a new instance of `Clock` is created, the `numberOfClocks` increases by one.

Also, look at the code in `Program.java`. You call the getter with the `Clock` class itselfâ€”`Clock.getNumberOfClocks()`â€”and not by the `grandfather` or `watch` instances because it's a class method. It's `static` too so it can access the `private static` class variable, `numberOfClocks`. The [static methods](https://lms.techelevator.com/cohorts/42/blocks/9/content_files/01_Classes_and_Encapsulation/06-static-modifier.md#static-methods) section explains why the getter also needs to be `static`:

```java
// Clock.java
public class Clock {
    private int hour;
    private int minute;
    private int second;

    private static int numberOfClocks; //static property

    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        numberOfClocks++; //numberOfClocks is incremented
    }

    public static int getNumberOfClocks() { //static getter
        return numberOfClocks;
    }
}
```

```java
// Program.java
public static void main(String[] args) {

    Clock grandfather = new Clock(11, 17, 42);
    System.out.println("The number of clocks is " + Clock.getNumberOfClocks());
    // Outputs "The number of clocks is 1"

    Clock watch = new Clock(16, 11, 1);
    System.out.println("The number of clocks is " + Clock.getNumberOfClocks());
    // Outputs "The number of clocks is 2"
}
```

>**âœ” Tip: Why is there no "this" for the static property?**
>
>If you recall, `this` refers to "this specific instance" of a class. Since static properties belong to the **_class_** and not the **_instance_**, you can't use `this` to refer to static properties.

### Constants
You learned about constants in an earlier unit, using the `final` keyword. Constants are often declared to be `static` as well. This is because when you declare a property to be `static`, it's only allocated memory once, even if it's part of a non-`static` class that has been instantiated more than once. This is a memory saving technique built into the Java language.

That earlier unit also introduced the concept of **_magic numbers_**. A magic number in programming is a unique value whose meaning is based upon its context, and you can't infer the significance of that value. In the following example, `24` is a magic number:

```java
int days = 2;

// ....

int numberOfHoursAwake = 24 * days;
```

In the `Clock` example, the `tick()` method uses magic numbers when determining if the seconds, minutes, or hours need to roll over. In fact, the number `60` means two different things: the number of seconds in a minute and the number of minutes in an hour. It'd be better if the numbers' meanings were explicitly called out. You can refactor this with static constants:

```java
// Clock.java
public class Clock {

    private static final int SECONDS_IN_A_MINUTE = 60;
    private static final int MINUTES_IN_AN_HOUR = 60;
    private static final int HOURS_IN_A_DAY = 24;

    private int hour;
    private int minute;
    private int second;

    public void tick() {
        this.second += 1;

        if (this.second >= SECONDS_IN_A_MINUTE) {
            this.minute += 1;
            this.second = 0;
        }

        if (this.minute >= MINUTES_IN_AN_HOUR) {
            this.hour += 1;
            this.minute = 0;
        }

        if (this.hour >= HOURS_IN_A_DAY) {
            this.hour = 0;
        }
    }
}
```

Notice the three new `private static final` variablesâ€”`SECONDS_IN_A_MINUTE`, `MINUTES_IN_AN_HOUR`, and `HOURS_IN_A_DAY`â€”and their usage in the `tick()` method. Now the code is much more readable.

>**âœ” Tip: Follow Java coding conventions**
>
>Constants in Java are typically written in all uppercase with underscores `_` in between words.

## Static methods
You can declare methods `static` like variables. The same rules apply: the `static` method belongs to the **_class_** itself and not an **_instance_** of it. You call it by using the class name, not the instance.

`static` methods are useful in a variety of scenarios. One good example is **utility methods**, or methods that help you perform a function but don't require an instance of an object.

Say for the `Clock` example, you wanted to create a function that converted a given timeâ€”not the time of an instanceâ€”into the number of seconds since midnight:

```java
// Clock.java
public class Clock {
    private static final int SECONDS_IN_A_MINUTE = 60;
    private static final int MINUTES_IN_AN_HOUR = 60;
    private static final int HOURS_IN_A_DAY = 24;

    private int hour;
    private int minute;
    private int second;

    private static int numberOfClocks;

    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        numberOfClocks++;
    }

    public static int getNumberOfClocks() {
        return numberOfClocks;
    }

    public static int getNumberOfSeconds(int hours, int minutes, int seconds) {
        return
          (hours * MINUTES_IN_AN_HOUR * SECONDS_IN_A_MINUTE) +
          (minutes * SECONDS_IN_A_MINUTE) +
          (seconds);
    }

    public void tick()
    {
        //...
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    // get the number of seconds since midnight for 1:20:23
    System.out.println(Clock.getNumberOfSeconds(1, 20, 23)); //4823
}
```

Notice that `Program.java` calls `Clock.getNumberOfSeconds()` without an instance existing, and that the method is `static` in `Clock.java`.

There's an important limitation to keep in mind when working with `static` methods and properties. `static` methods can **_only_** access other `static` methods or properties. If it's not `static`, you can't use it in a `static` method.

The `getNumberOfSeconds()` method can use the properties like `SECONDS_IN_A_MINUTE` because it's declared `static`. However, `getNumberOfSeconds()` wouldn't be able to call the `tick()` method because it's not `static`.

---

# Access modifiers

The keywords `public` and `private` are two of the most common access modifiers in the Java language. Access modifiers control visibility to methods and properties from the rest of your program.

## Public
The modifier keyword `public` marks something as publicly accessible, meaning other code can use or invoke it.

By making the `Clock` class public, any other code that references the `Clock` class can instantiate it.

Marking a property or method `public` indicates that any external caller can use it. An external caller may be an outside program, or another class within the application itself.

## Private
The `private` access modifier restricts access to a property or method. Private variables and methods are only visible from within the class that it's declared in.

In the `Clock` example, the class variables `hour`, `minute`, and `second` are all designated `private`. If you try to access them through an instance of your class, you receive a compiler error.

This allows you to hide your implementation away from users or outside callers of the class. Because it's only exposed through the getter and setter methods, you can restrict the values, access to the variable, or both:

```java
// Clock.java
public class Clock {
    private int hour;
    private int minute;
    private int second;

    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

     public void setHour(int hour) {
        if(hour >= 1 && hour <= 24) {
            this.hour = hour;
        }
    }

    public void setMinute(int minute) {
        if(minute >=0 && minute < 60) {
            this.minute = minute;
        }
    }

    public void setSecond(int second) {
        if(second >=0 && second < 60) {
            this.second = second;
        }
    }

    public int getHour() {
        return this.hour;
    }

    public int getMinute() {
        return this.minute;
    }

    public int getSecond() {
        return this.second;
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    // Creates a new clock initialized at 11:17:42
    Clock grandfather = new Clock(11, 17, 42);

    grandfather.hour = 12; //<-- not allowed, the instance variable is private
    grandfather.setHour(12); //<-- is allowed, the instance method is public
}
```

If it helps, think about classes as something seen from the outside, not the inside. `public` is what other programmers can see and is for things that can help someone perform a task.

However, programmers don't need to see everythingâ€”for example, the code that makes things work under the hood. In those cases, keep things private so that they're only accessible from within the class.

>**âœ” Tip: Use access modifiers for encapsulation**
>
>Access modifiers are another key feature of **encapsulation**. You can use access modifiers to restrict access to the internal mechanisms of how the class works by hiding or protecting its variables. This way, the values remain consistent and can only be changed through methods that the class allows external resources to have access to. In this way, a class controls how it's used and makes sure that use is consistent with its purpose.

For example, rather than having the user of the clock be able to change the second, minute, and hour manually, the clock receives an initial time when it's created, and internally manages the values when it ticks. Ideally, this limits the risk of bugs that appear in your code.

---

# Overloading methods and constructors

To provide users of your class with different options when they instantiate new objects or invoke methods, you can create an **overloaded method** or **overloaded constructor**.

As a programmer, when you overload a method or constructor, you add flexibility to your class so that users can leverage different inputs when interacting with it.

There are three rules of an overloaded method:

1.  Overloaded methods must **_have the same name_**.
2.  Overloaded methods must **_differ in the number of parameters, parameter types, or both_**.
3.  Overloaded methods can have different return types, but that **_must not_** be the only difference.

## Method overloading
In the following example, an overloaded method allows the programmer to "tick" the clock many times:

```java
// Clock.java
public class Clock {
    private int hour;
    private int minute;
    private int second;

    // Constructor
    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    // Overloaded method, relies on other tick method
    // but allows users to pass an int to say how many
    // times it ticks
    public void tick(int numberOfTimes) {
        for(int i = 1; i <= numberOfTimes; i++) {
            this.tick();    // calls tick() method below
        }
    }

    public void tick() {
        ///..
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    Clock grandfather = new Clock(11, 17, 42);

    // tick the clock 5 times
    grandfather.tick(5);// time will now be 11:17:47

    // tick the clock 1 time
    grandfather.tick(); // time will now be 11:17:48

    // Prints "Current time is 11:17:48
    System.out.println("Current time is " + grandfather.getCurrentTime());
}
```

>**ðŸ›ˆ Note: Method signature**
>
>A term to become familiar with is **method signature**. A method signature contains:
>
>-   The name of method
>-   The method parameters and the order of their data types
>
>The two `tick` methods have the signatures:
>
>-   `tick(int)`
>-   `tick()`
>
>A method signature is a way to differentiate overloaded methods, but it's also commonly used by programmers to describe any method.
>
>Take this method for example:
>
>```java
>public String sendBirthdayGreeting(String name, int age) {
>    ....
>}
>```
>
>The seasoned Java programmer says, "The method, `sendBirthdayGreeting`, has two parameters, a `String` and an `int`, and returns a `String`."

## Overloaded constructors
In the following code, an overloaded constructor allows the programmer to create a clock with specific values when instantiating a new clock:

```java
// Clock.java
public class Clock {
    private int hour = 7;       // Assigning values in order to
    private int minute = 45;    // default clock to 07:45:00 for
    private int second;         // demonstration purposes only

    // Constructor
    public Clock() {
        // Defaults established in property declarations.
    }

    // Overloaded Constructor
    public Clock(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }
}
```

```java
// Program.java
public static void main(String[] args) {
    Clock grandfather = new Clock(11, 17, 42);

    // Prints "Current time is 11:17:42"
    System.out.println("Current time is " + grandfather.getCurrentTime());

    Clock watch = new Clock();

    // Prints "Current time is 07:45:00"
    System.out.println("Current time is " + watch.getCurrentTime());
}
```

> Note: The default constructor `Clock()` doesn't set default values for `hour`, `minute`, and `second`, but it relies upon the values assigned in the property declaration.

---

# Loosely coupled code

To understand what loosely coupled code is, you need to know what **_tightly coupled_** code is and why it's bad.

**Coupling** is a measure of how closely connected two pieces of software are and how much they depend on each other. If you write your code in a way where changing one thing, like replacing a class or method with another, causes a ripple effect of changes that need to be made in other parts of your code, you've written **_tightly coupled_** code.

Ideally, you want to write your code in a way where one part doesn't have to rely heavily on the other being written or behaving in a certain way. Another way to phrase it: you don't want your components to know how the other one works.

Being able to write loosely coupled code is an important aspect of being a programmer. You're just learning how to write your own classes now, but as with many things, it's better to start with a good habit rather than breaking a bad habit later. You'll dive deeper into this topic at a later date, but it's good to keep in mind and start thinking about it now.

You saw examples of loosely coupled code when working with Collections. The reason you used `List` and `Map` as your variable types is because there are other classes that work with them besides `ArrayList` and `HashMap`:

```java
List<T> list = new ArrayList<T>();
Map<T> map = new HashMap<T>();
```

If you decided to replace the `ArrayList<T>` with `LinkedList<T>`, that would likely that would be the only line of code that needs to change and everything would still work as expected.

If you started off with defining the variable type as `ArrayList` and wanted to change it to `LinkedList` later, you might have to change more than that one line because they have different methods and behave differently. If you used the `List<T>` methods, the behavior would be the same.

If this sounds confusing, don't worry. It takes time to understand the concept of loosely coupled code. Over the next few lessons, you'll learn all the tools you'll need to write loosely coupled code.

---

# Organization of classes

When you began learning about Collections, you were briefly introduced to the concept of **packages**. Packages are a way to organize classes similar to organizing files on your computer. Like how you can find the photos from your last vacation in the `Pictures` folder on your computer, you can find the utility classes for Java in the `java.util` package.

Organizing classes like this also serves another purpose. Say you wanted to name your class `List`, and you didn't know that there was already a `List` class in `java.util`. Because your class is in a different package, like `com.myawesomecode.List`, it's technically different than `java.util.List`.

The same thing applies to files on your computer: you can have two files with the same name, but in different folders. The Java compiler knows which `List` you want because you specify which one you want to `import`.

Giving package names to your classes isn't required, but it's a best practice and you're strongly encouraged to do so. The package name must appear as the first line in your code. This is like saving a file to a specific folder on your computerâ€”the Java compiler stores your class in a specific package. You may have already noticed them in the code you've been working with up to now:

```java
package com.techelevator.codesamples;

public class NiftyClass {
    ...
}
```

If you wanted to use the `NiftyClass` in another application, you'd import it like so:

```java
package com.myawesomecode;

import com.techelevator.codesamples.NiftyClass;

public class MyAwesomeClass {
    NiftyClass nifty = new NiftyClass();
}
```

If the `com.techelevator.codesamples` package included other classes that you wanted to use, you'd import it like this:

```java
import com.techelevator.codesamples.*;
```

Some of the package names you've seen started with `com`. There are naming conventions for packages in Java. Typically, package names start with the "top-level domain" of a website. So, the `com` you see in the package name is the same as you see in websites like `techelevator.com`.

Next comes your domain or organization nameâ€”for example, `com.techelevator`. After that, it's up to the developer what organization of packages fits best, whether it be by functional purpose, versioning, or language. Lastly, it's standard for package names to be lowercase.

> Note: The packages that start with `java` are built-in packages.

If you want, you can read Java's documentation on [Naming Packages](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html) .

---

# Unit summary

In this unit, you learned:

-   How to create classes in Java
-   What encapsulation is and why it's used
-   The characteristics of a loosely coupled system
-   What `this` is and does
-   What `static` properties and methods are and what they're used for
-   About access modifiers and when you would use `private` versus `public`
-   Why getters and setters are better than public state
-   The parts of a method, what each does, which are optional, and which are required
-   What a method signature is in the Java language
-   How to use overloading in the Java language

---

# Quiz

## **Classes and Encapsulation 1**

**Which of these ideas are associated with encapsulation? (Select all that apply)**

	Select all correct options

â–  Bundling object state and behavior

â–¡ Validating user input

â–  Restricting direct access to internal properties

â–¡ Overloading methods

**Explanation:** Encapsulation supports and protects the internal logic and consistency of a class through bundling object state and behavior and restricting direct access to internal properties,


## **Classes and Encapsulation 2**

**Given the following code, what's the setter for `lastName`?**

```java
public class Person {
    private String lastName;
    ...
}
```

â—‹
```java
public String setLastName(String lastName) {
	this.lastName = lastName;
	return lastName;
}
```

â—‹
```java
public void setLastName() {
	lastName = lastName;
}
```

â—‹ 
```java
public void lastNameSet(String lastName) {
	this.lastName = lastName;
}
```

â—‰ 
```java
public void setLastName(String lastName) {
	this.lastName = lastName;
}
```

**Explanation:** Setters always begin with set followed by the name of the variable they're setting, take a single parameter with the same data type as the variable they set, and have a void return type.


## **Classes and Encapsulation 3**

**What does it mean to declare a property or method as `static`?**

â—‹ The property or method can be accessed from any other class.

â—‹ The property or method is loosely coupled.

â—‰ The property or method belongs to the class, and not an instance.

â—‹ The property or method contains noise and nothing useful.

**Explanation:** Static properties and static methods can be used without creating an instance of a class.


## **Classes and Encapsulation 4**

```java
public String makeCopies(String original, int numberOfCopies) {...}
```

**Which one of the following methods has the same method signature as `makeCopies`?**

â—‹ 
```java
public String repeatString(String original, int numberOfCopies) {...}
```

â—‹
```java
public String makeCopies(String original, long numberOfCopies) {...}
```

â—‹ 
```java
public String makeCopies(String original) {...}
```

â—‰ 
```java
private String makeCopies(String starter, int count) {...}
```

**Explanation:** The method signature is the same since the name of the method and the types of its parameters are the same. Changing the access modifier to `private` and changing the names of the parameters doesn't change the method signature.


## **Classes and Encapsulation 5**

**Which of the following statements are correct? (Select all that apply)**

	Select all correct options

â–  A class is a blueprint that defines the state and behaviors of a data type.

â–¡ A class can be overloaded.

â–¡ String is a primitive data type.

â–  An object is an instance of a class.

**Explanation:** Classes are blueprints that bring state (properties) and behaviors (methods) together, but they need to be instantiated into an object to be used.


## **Classes and Encapsulation 6**

**What access modifier hides properties and methods?**

â—‹ static

â—‰ private

â—‹ final

â—‹ public

**Explanation:** The `private` access modifier hides methods and instance variables and prevents access outside the class itself.


## **Classes and Encapsulation 7**

**What occurs when the following code compiles?**

```java
public class Greeter {
    ...
    public String happyBirthday(String name, int age) {
        return "Happy Birthday " + name + "! You are " + age + " years old.";
    }
    public String happyBirthday(int numberOfCandles, String message) {
        return message + "Wow! Your cake has " + numberOfCandles + " candles.";
    }
    ...
}
```

â—‰ The `happyBirthday` method is _overloaded_ by the Java compiler.

â—‹ The Java compiler throws an error saying there are duplicate `happyBirthday` methods because they have the same name, and both have int and String parameter types.

â—‹ It won't compile since you can't concatenate int values, such as `age` or `numberOfCandles`, to a string.

â—‹ It won't compile since the methods must use `this` to refer to the variables.

**Explanation:** The parameter types **_and_** their order are important in overloading methods. The two methods have int and String parameter types, but in a different order.


## **Classes and Encapsulation 8**

**Given the following code, which is the correct getter for the derived property `fullName`?**

```java
public class Person {

    private String firstName;
    private String lastName;
    ...
}
```

â—‹
```java
public String getFullName(String lastName, String firstName) {
	return lastName + ", " + firstName;
}
```

â—‹ 
```java
private String fullName;    // Additional instance variable
```

â—‹ 
```java
public String getFullName() {
	return this.fullName;
}
```

â—‰ 
```java
public String getFullName() {
	return this.lastName + ", " + this.firstName;
}
```

â—‹ 
```java
public void getFullName() {
	String fullName = this.lastName + ", " + this.firstName;
	return;
}
```

**Explanation:** A well-formed getter begins with get followed by the name of the property it's getting, has no parameters, and returns the data type of the property it gets.


## **Classes and Encapsulation 9**

**Java packages offer which of the following benefits? (Select all that apply)**

	Select all correct options

â–¡ They reduce memory since all classes in a package are compiled at the same time.

â–  They prevent your type names from colliding with others. your.Employee can be distinguished from their.Employee.

â–  They allow you to gather classes to logically relate them together.

â–¡ The Java compiler uses packages to optimize compilation which speeds up build-time.

**Explanation:** Packages exist in Java to avoid **_namespace_** collisions, and help document and explain how classes are logically related to one another.


## **Classes and Encapsulation 10**

**Consider the following code:**

```java
public class Greeter {
    private static int numberOfGreetings = 0;

    private static void trackGreetings() {
        numberOfGreetings++;
    }

    public String greet(String message, String name) {
        trackGreetings();   // directly call static trackGreetings()
        return "Hello, " + name + ". " + message;
    }
}
```

â—‹ Does Java allow an _instance_ method to directly call a static method in the same class like this?

â—‹ Yes, any method, regardless of whether it's static or not, can call any other method within the same class.

â—‹ It depends on whether the correct access modifiers are used. They need visibility to one another.

â—‹ Yes, the method signature rules permit instance methods to call static methods provided there is no reference to `this`.

â—‰ Yes, any static methods of a class are available to the instance methods of that class.

**Explanation:** Instance methods can always call static methods in the same class. Going the other direction is when there's a problem, since static methods don't have any object to call an instance method on.
